% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fparse.R
\name{fparse}
\alias{fparse}
\title{Fast and Friendly JSON String Parser}
\usage{
fparse(
  json,
  query = "",
  empty_array = NULL,
  empty_object = NULL,
  max_simplify_lvl = c("data_frame", "matrix", "vector", "list"),
  type_policy = c("anything_goes", "numbers", "strict"),
  int64_policy = c("double", "string", "integer64")
)
}
\arguments{
\item{json}{One or more \code{character}s of JSON data.}

\item{query}{String used as a JSON Pointer to identify a specific element within \code{json}.
\code{character(1L)}, default: \code{""}}

\item{empty_array}{Any R object to return for empty JSON arrays. 
default: \code{NULL}}

\item{empty_object}{Any R object to return for empty JSON objects.
default: \code{NULL}.}

\item{max_simplify_lvl}{Maximum simplification level.
 \code{character(1L)} or \code{integer(1L)}, default: \code{"data_frame"}
 \itemize{
   \item \code{"data_frame"} or \code{0L}
   \item \code{"matrix"} or \code{1L}
   \item \code{"vector"} or \code{2L}
   \item \code{"list"} or \code{3L} (no simplification)
}}

\item{type_policy}{Level of type strictness.
\code{character(1L)} or \code{integer(1L)}, default: \code{"anything_goes"}.
\itemize{
  \item \code{"anything_goes"} or \code{0L}: arrays always become atomic vectors
  \item \code{"numbers"} or \code{1L}: arrays containing only numbers always become atomic vectors
  \item \code{"strict"} or \code{2L}: arrays containing mixed types never become atomic vectors
 }}

\item{int64_policy}{How to return big integers to R.
\code{character(1L)} or \code{integer(1L)}, default: \code{"double"}.
\itemize{
  \item \code{"double"} or \code{0L}: big integers become \code{double}s
  \item \code{"string"} or \code{1L}: big integers become \code{character}s
  \item \code{"integer64"} or \code{2L}: big integers \code{bit64::integer64}s
}}
}
\description{
Fast and Friendly JSON String Parser
}
\details{
Instead of using \code{lapply()} for vectors containing multiple strings,
  just use \code{fparse()} directly as it is vectorized This is much more 
  efficient as the underlying \code{simdjson::dom::parser} can reuse internal
  buffers between parses. Since the overwhelming majority of JSON objects
  parsed will not result in R scalars, a \code{list()} is always returned 
  when multiple items are passed. Also in keeping with \code{lapply()}'s 
  behavior, if the data passed has \code{names()}, the returned object will 
  have the same names.
}
\examples{
# simple parsing ============================================================
json_string <- '{"a":[[1,null,3.0],["a","b",true],[10000000000,2,3]]}'
fparse(json_string)

# controlling type-strictness ===============================================
fparse(json_string, type_policy = "numbers")
fparse(json_string, type_policy = "strict")
fparse(json_string, type_policy = "numbers", int64_policy = "string")
fparse(json_string, type_policy = "numbers", int64_policy = "integer64")

# vectorized parsing ========================================================
json_strings <- c(
  json1 = '[{"b":true,
             "c":null},
            {"b":[[1,2,3],
                  [4,5,6]],
             "c":"Q"}]',
  json2 = '[{"b":[[7,8,9],
                  [10,11,12]],
             "c":"Q"},
            {"b":[[13,14,15],
                  [16,17,18]],
             "c":null}]'
)
fparse(json_strings)

# controlling simplification ================================================
fparse(json_strings, max_simplify_lvl = "matrix")
fparse(json_strings, max_simplify_lvl = "vector")
fparse(json_strings, max_simplify_lvl = "list")

# customizing what `[]` and `{}` return =====================================
empties <- '[[],{}]'
fparse(empties)
fparse(empties, empty_array = NA, empty_object = FALSE)

# querying JSON w/ a JSON Pointer ===========================================
json_to_query <- c(
  json1 = '[
      "a",
      {
          "b": {
              "c": [
                  [
                      1,
                      2,
                      3
                  ],
                  [
                      4,
                      5,
                      6
                  ]
              ]
          }
      }
  ]
  ',
  json2 = '[
      "a",
      {
          "b": {
              "c": [
                  [
                      7,
                      8,
                      9
                  ],
                  [
                      10,
                      11,
                      12
                  ]
              ]
          }
      }
  ]'
)
fparse(json_to_query, query = "1")
fparse(json_to_query, query = "1/b")
fparse(json_to_query, query = "1/b/c")
fparse(json_to_query, query = "1/b/c/1")
fparse(json_to_query, query = "1/b/c/1/0")

}
